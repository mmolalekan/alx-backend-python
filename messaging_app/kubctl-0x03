#!/bin/bash

# kubctl-0x03 - Rolling Update Script
# This script performs a rolling update to version 2.0 and monitors for downtime

set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Function to continuously test the application
continuous_health_check() {
    local service_name=$1
    local duration=$2
    local interval=$3
    
    print_info "Starting continuous health checks for ${duration}s with ${interval}s interval..."
    
    local success_count=0
    local total_count=0
    local start_time=$(date +%s)
    local end_time=$((start_time + duration))
    
    while [ $(date +%s) -lt $end_time ]; do
        # Port forward temporarily for each check
        kubectl port-forward service/$service_name 8081:8000 > /dev/null 2>&1 &
        local pf_pid=$!
        sleep 2
        
        if curl -s -f http://localhost:8081/api/health/ > /dev/null; then
            success_count=$((success_count + 1))
            echo -n "✅"
        else
            echo -n "❌"
        fi
        
        total_count=$((total_count + 1))
        kill $pf_pid 2>/dev/null || true
        sleep $interval
    done
    
    echo ""  # New line after progress dots
    local success_rate=$((success_count * 100 / total_count))
    
    if [ $success_rate -eq 100 ]; then
        print_success "Zero downtime achieved! Success rate: ${success_rate}% (${success_count}/${total_count})"
    elif [ $success_rate -ge 95 ]; then
        print_warning "Minimal disruption. Success rate: ${success_rate}% (${success_count}/${total_count})"
    else
        print_error "Significant downtime detected! Success rate: ${success_rate}% (${success_count}/${total_count})"
    fi
}

# Function to get current pod versions
get_pod_versions() {
    print_info "Current pod versions:"
    kubectl get pods -l app=django-app -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[0].image}{"\t"}{.status.phase}{"\n"}{end}'
}

# Function to monitor rollout progress
monitor_rollout() {
    local deployment=$1
    
    print_info "Monitoring rollout progress for $deployment..."
    
    # Start monitoring in background
    kubectl rollout status deployment/$deployment --watch --timeout=300s &
    local monitor_pid=$!
    
    # Monitor pod changes in real-time
    while ps -p $monitor_pid > /dev/null; do
        echo "=== Current Pod Status ==="
        kubectl get pods -l app=django-app -o wide | grep $deployment
        echo "=========================="
        sleep 5
    done
    
    wait $monitor_pid
    return $?
}

# Main execution
echo "=========================================="
echo "Rolling Update to Version 2.0"
echo "=========================================="

# Get current state
print_info "Initial state before update:"
get_pod_versions

# Determine which deployment is active
ACTIVE_SERVICE=$(kubectl get service django-app-main-service -o jsonpath='{.spec.selector.version}')
print_info "Currently active deployment: $ACTIVE_SERVICE"

if [ "$ACTIVE_SERVICE" != "blue" ]; then
    print_warning "Blue deployment is not currently active. Consider switching traffic first."
    read -p "Do you want to continue with the update? (y/n): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Start continuous health checks in background
print_info "Starting background health monitoring..."
continuous_health_check "django-app-main-service" 300 2 &
health_check_pid=$!

# Apply the updated deployment
print_info "Applying updated blue deployment (version 2.0)..."
kubectl apply -f blue_deployment.yaml

# Monitor the rollout
if monitor_rollout "django-app-blue"; then
    print_success "Rolling update completed successfully!"
else
    print_error "Rolling update failed!"
    # Wait for health check to complete
    wait $health_check_pid
    exit 1
fi

# Wait for health check to complete
print_info "Waiting for health monitoring to complete..."
wait $health_check_pid

# Final verification
print_info "Final verification:"
get_pod_versions

# Check rollout history
print_info "Rollout history:"
kubectl rollout history deployment/django-app-blue

# Verify all pods are running new version
print_info "Verifying all pods are running version 2.0..."
NEW_PODS=$(kubectl get pods -l app=django-app,version=blue -o jsonpath='{.items[*].spec.containers[0].image}' | tr ' ' '\n' | uniq)

if [ "$NEW_PODS" == "django-messaging-app:2.0" ]; then
    print_success "All pods successfully updated to version 2.0!"
else
    print_error "Not all pods are running version 2.0: $NEW_PODS"
    exit 1
fi

# Performance check
print_info "Performing final performance check..."
kubectl port-forward service/django-app-main-service 8082:8000 > /dev/null 2>&1 &
final_pf_pid=$!
sleep 3

if curl -s http://localhost:8082/api/health/ | grep -q "healthy"; then
    print_success "Application is healthy and responding correctly"
else
    print_error "Application health check failed after update"
fi

kill $final_pf_pid 2>/dev/null

print_success "=========================================="
print_success "Rolling update to version 2.0 completed!"
print_success "Zero-downtime deployment verified!"
print_success "=========================================="